{
  "name": "gravity",
  "type": "registry:ui",
  "dependencies": [
    "lodash",
    "matter-js",
    "svg-path-commander",
    "poly-decomp"
  ],
  "files": [
    {
      "path": "/fancy/physics/gravity.tsx",
      "content": "\"use client\"\n\nimport {\n  createContext,\n  forwardRef,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\nimport { calculatePosition } from \"@/utils/calculate-position\"\nimport { parsePathToVertices } from \"@/utils/svg-path-to-vertices\"\nimport { debounce } from \"lodash\"\nimport Matter, {\n  Bodies,\n  Common,\n  Engine,\n  Events,\n  Mouse,\n  MouseConstraint,\n  Query,\n  Render,\n  Runner,\n  World,\n} from \"matter-js\"\n\nimport { cn } from \"@/lib/utils\"\n\ntype GravityProps = {\n  children: ReactNode\n  debug?: boolean\n  gravity?: { x: number; y: number }\n  resetOnResize?: boolean\n  grabCursor?: boolean\n  addTopWall?: boolean\n  autoStart?: boolean\n  className?: string\n}\n\ntype PhysicsBody = {\n  element: HTMLElement\n  body: Matter.Body\n  props: MatterBodyProps\n}\n\ntype MatterBodyProps = {\n  children: ReactNode\n  matterBodyOptions?: Matter.IBodyDefinition\n  isDraggable?: boolean\n  bodyType?: \"rectangle\" | \"circle\" | \"svg\"\n  sampleLength?: number\n  x?: number | string\n  y?: number | string\n  angle?: number\n  className?: string\n}\n\nexport type GravityRef = {\n  start: () => void\n  stop: () => void\n  reset: () => void\n}\n\nconst GravityContext = createContext<{\n  registerElement: (\n    id: string,\n    element: HTMLElement,\n    props: MatterBodyProps\n  ) => void\n  unregisterElement: (id: string) => void\n} | null>(null)\n\nexport const MatterBody = ({\n  children,\n  className,\n  matterBodyOptions = {\n    friction: 0.1,\n    restitution: 0.1,\n    density: 0.001,\n    isStatic: false,\n  },\n  bodyType = \"rectangle\",\n  isDraggable = true,\n  sampleLength = 15,\n  x = 0,\n  y = 0,\n  angle = 0,\n  ...props\n}: MatterBodyProps) => {\n  const elementRef = useRef<HTMLDivElement>(null)\n  const idRef = useRef(Math.random().toString(36).substring(7))\n  const context = useContext(GravityContext)\n\n  useEffect(() => {\n    if (!elementRef.current || !context) return\n    context.registerElement(idRef.current, elementRef.current, {\n      children,\n      matterBodyOptions,\n      bodyType,\n      sampleLength,\n      isDraggable,\n      x,\n      y,\n      angle,\n      ...props,\n    })\n\n    return () => context.unregisterElement(idRef.current)\n  }, [props, children, matterBodyOptions, isDraggable])\n\n  return (\n    <div\n      ref={elementRef}\n      className={cn(\n        \"absolute\",\n        className,\n        isDraggable && \"pointer-events-none\"\n      )}\n    >\n      {children}\n    </div>\n  )\n}\n\nconst Gravity = forwardRef<GravityRef, GravityProps>(\n  (\n    {\n      children,\n      debug = false,\n      gravity = { x: 0, y: 1 },\n      grabCursor = true,\n      resetOnResize = true,\n      addTopWall = true,\n      autoStart = true,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const canvas = useRef<HTMLDivElement>(null)\n    const engine = useRef(Engine.create())\n    const render = useRef<Render>()\n    const runner = useRef<Runner>()\n    const bodiesMap = useRef(new Map<string, PhysicsBody>())\n    const frameId = useRef<number>()\n    const mouseConstraint = useRef<Matter.MouseConstraint>()\n    const mouseDown = useRef(false)\n    const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 })\n\n    const isRunning = useRef(false)\n\n    // Register Matter.js body in the physics world\n    const registerElement = useCallback(\n      (id: string, element: HTMLElement, props: MatterBodyProps) => {\n        if (!canvas.current) return\n        const width = element.offsetWidth\n        const height = element.offsetHeight\n        const canvasRect = canvas.current!.getBoundingClientRect()\n\n        const angle = (props.angle || 0) * (Math.PI / 180)\n\n        const x = calculatePosition(props.x, canvasRect.width, width)\n        const y = calculatePosition(props.y, canvasRect.height, height)\n\n        let body\n        if (props.bodyType === \"circle\") {\n          const radius = Math.max(width, height) / 2\n          body = Bodies.circle(x, y, radius, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        } else if (props.bodyType === \"svg\") {\n          const paths = element.querySelectorAll(\"path\")\n          const vertexSets: Matter.Vector[][] = []\n\n          paths.forEach((path) => {\n            const d = path.getAttribute(\"d\")\n            const p = parsePathToVertices(d!, props.sampleLength)\n            vertexSets.push(p)\n          })\n\n          body = Bodies.fromVertices(x, y, vertexSets, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        } else {\n          body = Bodies.rectangle(x, y, width, height, {\n            ...props.matterBodyOptions,\n            angle: angle,\n            render: {\n              fillStyle: debug ? \"#888888\" : \"#00000000\",\n              strokeStyle: debug ? \"#333333\" : \"#00000000\",\n              lineWidth: debug ? 3 : 0,\n            },\n          })\n        }\n\n        if (body) {\n          World.add(engine.current.world, [body])\n          bodiesMap.current.set(id, { element, body, props })\n        }\n      },\n      [debug]\n    )\n\n    // Unregister Matter.js body from the physics world\n    const unregisterElement = useCallback((id: string) => {\n      const body = bodiesMap.current.get(id)\n      if (body) {\n        World.remove(engine.current.world, body.body)\n        bodiesMap.current.delete(id)\n      }\n    }, [])\n\n    // Keep react elements in sync with the physics world\n    const updateElements = useCallback(() => {\n      bodiesMap.current.forEach(({ element, body }) => {\n        const { x, y } = body.position\n        const rotation = body.angle * (180 / Math.PI)\n\n        element.style.transform = `translate(${\n          x - element.offsetWidth / 2\n        }px, ${y - element.offsetHeight / 2}px) rotate(${rotation}deg)`\n      })\n\n      frameId.current = requestAnimationFrame(updateElements)\n    }, [])\n\n    const initializeRenderer = useCallback(() => {\n      if (!canvas.current) return\n\n      const height = canvas.current.offsetHeight\n      const width = canvas.current.offsetWidth\n\n      Common.setDecomp(require(\"poly-decomp\"))\n\n      engine.current.gravity.x = gravity.x\n      engine.current.gravity.y = gravity.y\n\n      render.current = Render.create({\n        element: canvas.current,\n        engine: engine.current,\n        options: {\n          width,\n          height,\n          wireframes: false,\n          background: \"#00000000\",\n        },\n      })\n\n      const mouse = Mouse.create(render.current.canvas)\n      mouseConstraint.current = MouseConstraint.create(engine.current, {\n        mouse: mouse,\n        constraint: {\n          stiffness: 0.2,\n          render: {\n            visible: debug,\n          },\n        },\n      })\n\n      // Add walls\n      const walls = [\n        // Floor\n        Bodies.rectangle(width / 2, height + 10, width, 20, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n\n        // Right wall\n        Bodies.rectangle(width + 10, height / 2, 20, height, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n\n        // Left wall\n        Bodies.rectangle(-10, height / 2, 20, height, {\n          isStatic: true,\n          friction: 1,\n          render: {\n            visible: debug,\n          },\n        }),\n      ]\n\n      const topWall = addTopWall\n        ? Bodies.rectangle(width / 2, -10, width, 20, {\n            isStatic: true,\n            friction: 1,\n            render: {\n              visible: debug,\n            },\n          })\n        : null\n\n      if (topWall) {\n        walls.push(topWall)\n      }\n\n      const touchingMouse = () =>\n        Query.point(\n          engine.current.world.bodies,\n          mouseConstraint.current?.mouse.position || { x: 0, y: 0 }\n        ).length > 0\n\n      if (grabCursor) {\n        Events.on(engine.current, \"beforeUpdate\", (event) => {\n          if (canvas.current) {\n            if (!mouseDown.current && !touchingMouse()) {\n              canvas.current.style.cursor = \"default\"\n            } else if (touchingMouse()) {\n              canvas.current.style.cursor = mouseDown.current\n                ? \"grabbing\"\n                : \"grab\"\n            }\n          }\n        })\n\n        canvas.current.addEventListener(\"mousedown\", (event) => {\n          mouseDown.current = true\n\n          if (canvas.current) {\n            if (touchingMouse()) {\n              canvas.current.style.cursor = \"grabbing\"\n            } else {\n              canvas.current.style.cursor = \"default\"\n            }\n          }\n        })\n        canvas.current.addEventListener(\"mouseup\", (event) => {\n          mouseDown.current = false\n\n          if (canvas.current) {\n            if (touchingMouse()) {\n              canvas.current.style.cursor = \"grab\"\n            } else {\n              canvas.current.style.cursor = \"default\"\n            }\n          }\n        })\n      }\n\n      World.add(engine.current.world, [mouseConstraint.current, ...walls])\n\n      render.current.mouse = mouse\n\n      runner.current = Runner.create()\n      Render.run(render.current)\n      updateElements()\n      runner.current.enabled = false\n\n      if (autoStart) {\n        runner.current.enabled = true\n        startEngine()\n      }\n    }, [updateElements, debug, autoStart])\n\n    // Clear the Matter.js world\n    const clearRenderer = useCallback(() => {\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n\n      if (mouseConstraint.current) {\n        World.remove(engine.current.world, mouseConstraint.current)\n      }\n\n      if (render.current) {\n        Mouse.clearSourceEvents(render.current.mouse)\n        Render.stop(render.current)\n        render.current.canvas.remove()\n      }\n\n      if (runner.current) {\n        Runner.stop(runner.current)\n      }\n\n      if (engine.current) {\n        World.clear(engine.current.world, false)\n        Engine.clear(engine.current)\n      }\n\n      bodiesMap.current.clear()\n    }, [])\n\n    const handleResize = useCallback(() => {\n      if (!canvas.current || !resetOnResize) return\n\n      const newWidth = canvas.current.offsetWidth\n      const newHeight = canvas.current.offsetHeight\n\n      setCanvasSize({ width: newWidth, height: newHeight })\n\n      // Clear and reinitialize\n      clearRenderer()\n      initializeRenderer()\n    }, [clearRenderer, initializeRenderer, resetOnResize])\n\n    const startEngine = useCallback(() => {\n      if (runner.current) {\n        runner.current.enabled = true\n\n        Runner.run(runner.current, engine.current)\n      }\n      if (render.current) {\n        Render.run(render.current)\n      }\n      frameId.current = requestAnimationFrame(updateElements)\n      isRunning.current = true\n    }, [updateElements, canvasSize])\n\n    const stopEngine = useCallback(() => {\n      if (!isRunning.current) return\n\n      if (runner.current) {\n        Runner.stop(runner.current)\n      }\n      if (render.current) {\n        Render.stop(render.current)\n      }\n      if (frameId.current) {\n        cancelAnimationFrame(frameId.current)\n      }\n      isRunning.current = false\n    }, [])\n\n    const reset = useCallback(() => {\n      stopEngine()\n      bodiesMap.current.forEach(({ element, body, props }) => {\n        body.angle = props.angle || 0\n\n        const x = calculatePosition(\n          props.x,\n          canvasSize.width,\n          element.offsetWidth\n        )\n        const y = calculatePosition(\n          props.y,\n          canvasSize.height,\n          element.offsetHeight\n        )\n        body.position.x = x\n        body.position.y = y\n      })\n      updateElements()\n      handleResize()\n    }, [])\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        start: startEngine,\n        stop: stopEngine,\n        reset,\n      }),\n      [startEngine, stopEngine]\n    )\n\n    useEffect(() => {\n      if (!resetOnResize) return\n\n      const debouncedResize = debounce(handleResize, 500)\n      window.addEventListener(\"resize\", debouncedResize)\n\n      return () => {\n        window.removeEventListener(\"resize\", debouncedResize)\n        debouncedResize.cancel()\n      }\n    }, [handleResize, resetOnResize])\n\n    useEffect(() => {\n      initializeRenderer()\n      return clearRenderer\n    }, [initializeRenderer, clearRenderer])\n\n    return (\n      <GravityContext.Provider value={{ registerElement, unregisterElement }}>\n        <div\n          ref={canvas}\n          className={cn(className, \"absolute top-0 left-0 w-full h-full\")}\n          {...props}\n        >\n          {children}\n        </div>\n      </GravityContext.Provider>\n    )\n  }\n)\n\nGravity.displayName = \"Gravity\"\nexport default Gravity\n",
      "type": "registry:ui",
      "target": "/components/fancy/gravity.tsx"
    },
    {
      "path": "/utils/calculate-position.ts",
      "content": "export function calculatePosition(\n  value: number | string | undefined,\n  containerSize: number,\n  elementSize: number\n): number {\n  // Handle percentage strings (e.g. \"50%\")\n  if (typeof value === \"string\" && value.endsWith(\"%\")) {\n    const percentage = parseFloat(value) / 100\n    return containerSize * percentage\n  }\n\n  // Handle direct pixel values\n  if (typeof value === \"number\") {\n    return value\n  }\n\n  // If no value provided, center the element\n  return (containerSize - elementSize) / 2\n}\n",
      "type": "registry:lib",
      "target": "/utils/calculate-position.ts"
    },
    {
      "path": "/utils/svg-path-to-vertices.ts",
      "content": "import SVGPathCommander from \"svg-path-commander\"\n\n// Function to convert SVG path `d` to vertices\nexport function parsePathToVertices(path: string, sampleLength = 15) {\n  // Convert path to absolute commands\n  const commander = new SVGPathCommander(path)\n\n  const points: { x: number; y: number }[] = []\n  let lastPoint: { x: number; y: number } | null = null\n\n  // Get total length of the path\n  const totalLength = commander.getTotalLength()\n  let length = 0\n\n  // Sample points along the path\n  while (length < totalLength) {\n    const point = commander.getPointAtLength(length)\n\n    // Only add point if it's different from the last one\n    if (!lastPoint || point.x !== lastPoint.x || point.y !== lastPoint.y) {\n      points.push({ x: point.x, y: point.y })\n      lastPoint = point\n    }\n\n    length += sampleLength\n  }\n\n  // Ensure we get the last point\n  const finalPoint = commander.getPointAtLength(totalLength)\n  if (\n    lastPoint &&\n    (finalPoint.x !== lastPoint.x || finalPoint.y !== lastPoint.y)\n  ) {\n    points.push({ x: finalPoint.x, y: finalPoint.y })\n  }\n\n  return points\n}",
      "type": "registry:lib",
      "target": "/utils/svg-path-to-vertices.ts"
    }
  ],
  "devDependencies": [
    "@types/matter-js"
  ]
}